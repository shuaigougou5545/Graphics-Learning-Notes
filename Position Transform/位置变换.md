# 位置变换

💡手撸一遍顶点变化，从局部空间开始，最后输出到屏幕的像素点 **<源于西山居笔试编程题～>**

⚠️注意的点：

- view矩阵，通过right、up、forward、cameraW构造view矩阵要注意什么，得到的view矩阵需要取逆吗
- 如何求矩阵的逆，对于正交矩阵来说，它的逆是如何
- 透视除法中，w分量为0怎么办
- 不同api的差异：比如ndc空间的范围是多少（不同api下）
- 映射到屏幕空间的像素点如何计算，需要四舍五入（`round`）吗

##### 代码：在main.cpp中，数据在data.txt中，使用重定向将数据导入

```cpp
g++ ./main.cpp -o main -std=c++11
./main < data.txt
```

‼️**Api之间的差别**：

|                 |          OpenGL          |              DirectX               | 备注 |
| :-------------: | :----------------------: | :--------------------------------: | :--: |
|     坐标系      |        右手坐标系        |             左手坐标系             |      |
|    矩阵/向量    |          列矩阵          |               行矩阵               |      |
|  向量/矩阵乘法  |           左乘           |                右乘                |      |
| ndc空间坐标范围 | x,y,z∈[-1,1]<sup>3</sup> | x,y∈[-1,1]<sup>2</sup> **z∈[0,1]** |      |
|                 |                          |                                    |      |
|                 |                          |                                    |      |
|                 |                          |                                    |      |
|                 |                          |                                    |      |
|                 |                          |                                    |      |

##### 罗德里格旋转公式：

<img src="https://cdn.jsdelivr.net/gh/shuaigougou5545/blog-image/img/202306041508474.jpg" alt="罗德里格" style="zoom:20%;" />


$$
假设:\vec{n}是单位向量，向量\vec{v}绕旋转轴\vec{n}旋转\theta角度
\\ \vec{v}=\vec{v_\parallel} + \vec{v_\bot}
\\ \vec{v_\parallel}=(\vec{n}\cdot \vec{v})\vec{n}\ \ \ \ \vec{v_\bot} = \vec{v}-\vec{v_\parallel}
\\ 对\vec{v_\bot}进行旋转，我们建立一个垂直于\vec{n}的平面
\\ x轴:\vec{v_\bot}
\\ y轴:(\vec{v_\bot}\times \vec{n}) 或者(\vec{v}\times \vec{n})
\\ \because ||\vec{v}\times\vec{n}||=||\vec{v}||\cdot sin\alpha=||\vec{v_\bot}||
\\ \vec{v_\bot}'=||\vec{v_\bot}||\cdot cos\theta\cdot \frac{\vec{v_\bot}}{||\vec{v_\bot}||}+||\vec{v_\bot}||\cdot sin\theta\cdot\frac{\vec{v}\times \vec{n}}{||\vec{v}\times\vec{n}||}
\\ =\vec{v_\bot}\cdot cos\theta+\vec{v}\times \vec{n}\cdot sin\theta
\\ \therefore \vec{v}'=\vec{v_\parallel} + \vec{v_\bot}'
\\ \vec{v}'=(\vec{n}\cdot \vec{v})\vec{n}+(\vec{v}-(\vec{n}\cdot \vec{v})\vec{n})\cdot cos\theta+(\vec{v}\times\vec{n})\cdot sin\theta
$$
所以总公式为：
$$
{\color{Red} R_n(v)=proj_n(v)+R_n(v_\bot)}
\\ {\color{Red} =cos\theta \textbf{v}+(1-cos\theta)(\textbf{n}\cdot \textbf{v})\textbf{n}+sin\theta(\textbf{n}\times \textbf{v})}
$$
对应的旋转矩阵为：
$$
n=(x,y,z) \ \ \ \ \theta
\\ R_n=\begin{bmatrix} cos\theta+(1-cos\theta)x^2 & (1-cos\theta)xy+sin\theta z & (1-cos\theta)xz-sin\theta y \\ (1-cos\theta) xy-sin\theta z & cos\theta+(1-cos\theta)y^2 & (1-cos\theta)yz+sin\theta x\\ (1-cos\theta)xz+sin\theta y & (1-cos\theta)yz-sin\theta x & cos\theta+(1-cos\theta)z^2 \end{bmatrix}
$$
该推导的关键点在于：旋转平面的y轴方向，如果能用v代替v垂直，则问题迎刃而解～

##### 线性变换的推导：=> 矩阵每行是标准基向量做某种变换后的新向量

线性变换需要满足的条件：
$$
\tau(\vec{u}+\vec{v})=\tau(\vec{u})+\tau(\vec{v})
\\ \tau(k\vec{u})=k\tau(\vec{u})
$$
如果一个变换是线性变换，那么它就可以写成矩阵的形式：
$$
p=(x,y,z)=x\vec{i}+y\vec{j}+z\vec{k}
\\ \tau(p)=\tau(x\vec{i}+y\vec{j}+z\vec{k})=x\cdot \tau({\vec{i}})+y\cdot\tau({\vec{j}})+z\cdot\tau(\vec{k})
\\ = \begin{bmatrix} 
x & y & z
\end{bmatrix}
\begin{bmatrix} 
\tau({\vec{i}}) \\
\tau({\vec{j}}) \\
\tau({\vec{k}})
\end{bmatrix}
$$

```cpp
注意:具体乘法的时候又是"交叉"的，也就是说x'=x·m[0][0]+y·m[0][1]+z·m[0][2]
m矩阵的一列贯穿了三个行向量，但是x只会乘上\tau(i)的对应分量
```

那就只需要证明S、R是线性变换，加上T是仿射变化即可：



##### 坐标系之间的变换：尤其是local => world => view



##### 遇到的新问题与解决：

- model矩阵：
  - 分别推导S、R、T矩阵时，S、R、T矩阵初始化必须是单位矩阵，而不能是零矩阵